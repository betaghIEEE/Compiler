\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{algorithm,algorithmic}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\textwidth = 6.5 in
\textheight = 9 in
\oddsidemargin = 0.0 in
\evensidemargin = 0.0 in
\topmargin = 0.0 in
\headheight = 0.0 in
\headsep = 0.0 in
\parskip = 0.2in
\parindent = 0.0in

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}{Definition}

\title{Semantic Action notes}
\author{Dan Beatty}
\begin{document}
\maketitle
Generic Quad Generation:
$E\to TE'$
$E' \to +TE'$
$E' \to \epsilon$
$T\to FT'$
$T' \to \ast FT'$
$T' \to \epsilon$
$F \to ( E) $
$F\to i_d$

a := pop
b := pop
c := gentemp
genquad ( +, b,a,c)
push (c)

a := pop
b := pop
c := gentemp
genquad ( *, b, a, c)
push (c)

push (id)

(a + b ) * 3



The task for this to generate semantic actions for this somewhat simple grammar and another example will be used to reinforce the principle.  (Time index 2:39)  Notice in this grammar several semantic actions are performed.  The order of traversal and the actions taken matter.   These semantic actions fill the semantic action stack (SAS) and fills temporary variables NQ (next quad), a,b, and c in these actions.  The operation genquad has a side effect in advancing the NQ counter.  Also t2 is left on the stack after all pushed and popped.

General Rules 
Every time that gen quad is called, there is an implicit incrementing of next quad (NQ).  Unique integers must exist to provide quad-table operations.  Integer locations for local variables must also exist, which are links to the symbol table (lexical analyzer).  Negative integers may a good suggestion for temporary variables, or members of the symbol table.  If it is a member of the symbol table, then gentemp must add that temporary variable reference to the symbol table.  There is an important separation that exist between the op code of the quad table and the reserved words of the symbol table.  A similar separation exist for the quad-table op code and the machine op code.    

The operations include jump, jump equal, jump not equal, plus, and multiply.

Any type of \underline{expression \underline{will}} leave its result on the SAS.  For N pops there are N+1 pushes for each expression evaluated.  This forces an asymmetric relationship between push and pop.  

Any type of statement will leave the stack empty as far as the statement is concerned.   When any type of statement is processed (such read, write, for, while, etc), the processing starts with the assumption that the stack is empty,  regardless if it is, and finish processing with assumption that the stack is empty.   The relationship on push pop is $N_{pop} \ge N_{push}$.

SAS
a
b

local variable a 	1	11
local variable b	I 
local variable c  	t1
NQ	10 	11	12	13	33




Example: For Loop
$S \to ... | for i_d := E\ to\ E\ do\ S\ od$

The state of the stack before semantic action C (before statement S) is the same as after statement S.  

There needs to be a semantic action A, to identify the identifier for the loop statement.   Semantic action needs to follow the first expression to collect the result from the expression, E.  

Also to be noted, when genquad has an empty operand, that operand is represented with a zero.  

Semantic action A
push (id)

Semantic action B
a := pop (result of expression RHS)
b := pop (id LHS)
c := genquad (:= , a,  , b)
push(b)
 
Semantic action C
c := gentemp 
a := pop ( result of expression) 
b := pop (id)
push (b)
push (NQ)
genquad ( <= , a, b, c)
genquad ( jeq, c, false, \_ )

Semantic action D
a := pop (NQ)
b := pop (id)
genquad ( +, id, t, id)
genquad ( jmp, , , a)
QUADS[a+1,4] := NQ 

Sample
for i := 1 to 10 do
	S: S ... od

a 	1	11
b	I 
c  	t1
NQ	10 	11	12	13	33

Note: this is the NQ before the genquad statement which increments NQ.

10 11 12 13

$S \to ID\ :=\  E$

Semantic action A
push (A)


Semantic action B
a := pop
b := pop
genquad (:= , a, , b)

\textbf {\Large Another example } $while\  C\ do \ S \ od$

Semantic action A
a := pop
push (NQ)
genquad (jeq, a, false, \_)

Semantic action B
a := pop
genquad (jmp, \_ , \_ , a)
QUADS [a, 4] := NQ

a
NQ

Example at 1:15:07


Parsing is started with E (the start symbol).

Given this expression from the grammar,  $(E_L) (E_L) + $, try to make a semantic action
 
 A at beginning, B inbetween )(, and C at )+.  There are two stacks required to aid in this semantic action, in addition to the SAS.   We use the marker \# to indicate that results are about to be generated by an expression.  These results can be lists of results, and they are pushed onto the SAS.   The marker is used in subsequent semantic actions such as B to indicate a stop condition.  The two addition stacks introduced as $S_1$ and $S_2$ are for storage of the results of each expression list.   Pushes and pops are taken with regard to their respective stack.  
 
 Also are included local variables, A, and B.  
 
 Note that this mechanism allows EL to be a list, and for those elements to be added and stored as a list.  
 
 Semantic action A 
 	push (\#)SAS
 
 Semantic action B has
 \begin{itemize}
\item A = pop(SAS)
\item   while A $neq$ \# do 
 \begin{itemize}
\item  push (A, $S_1$)
\item A := pop (SAS)
\end{itemize}
\item push (\#) SAS
\end{itemize}

 Semantic action B 
	A = pop(SAS)
	while A $neq$ \# do 
		push (A, $S_1$)
		A := pop (SAS)
	push (\#) SAS

Semantic action C has 
\begin{itemize}
\item A := A := pop(SAS)
\item while A $\neq$ \# do
\begin{itemize}
\item push(A,SZ)
\item A := pop (SAS)
\end{itemize}
\item push (\#) SAS
\item A := pop(S1)
\item B := pop (S2)
\item while A $\neq$ empty do
\begin{itemize}
\item C := gentemp
\item genquad (+, A, B, C)
\item push (C) SAS
\item A := pop (S1)
\item B := pop (S2)
\end{itemize}

\end{itemize}

Example: (1,2,3) (4,5,6) + 

Note that a test of B in addition to A in semantic action C can indicate a semantic error.

Given:
Given this statement from the grammar,  $(I_L)(E_L) :=$, try to make a semantic action

(IL)(EL) :=

The first action pushes a marker on to the SAS to indicate a stop condition, which is semantic action A.  The next step is to retrieve the results of EL off of the stack and preserve them in their own stack.

Presumption:  IL puts its list of elements on the SAS.  These elements can be retrieved as shown in semantic action B.  In semantic action B, these elements are placed on their own stack, the results of EL are also placed on their own stack, and the results are popped together.  As each element is popped, the element of EL is assigned to the element of IL and eventually the production is complete.  


A at the beginning has
Semantic Action A
\begin{itemize}
\item push (\#)
\end{itemize}

B at the end of the production
Semantic Action B
\begin{itemize}
\item A := pop (SAS)
\item while A $\neq$ \# do 
\begin{itemize}
\item push (A,S1)
\item A := pop (SAS)
\end{itemize}
\item A := pop(SAS)
\item while A $\neq$ \# do
\begin{itemize}
\item push (A, S2)
\item A := pop (SAS)
\end{itemize}
\item A := pop (S1)
\item B := pop(S2)
\item while A $\neq$ \# empty do
\begin{itemize}
\item genquad ( = A, \_ , B)
\item A := pop(S1)
\item B := pop(S2)
\end{itemize}

\end{itemize}

(x,y,z)  ((1,2,3)(4,5,6)+) := 


\textbf{\Large Another production:}
$\{SL\}\ id\ from\ [E\ ..\ E]$
This production is found in $S'$ which is called by production $S \to \alpha_{12} S_L \alpha_13 S'$.  This production may produce some difficulty.  The meaning of this production is execute the statements in this statement list with some identifier taking values from some expression to another expression stated in a bracketed list.  There is an analogous to a for loop such that 

for id := E1 to E2 
	SL
This implies that this statement is handled the same way as a for loop.  


\textbf{Symbol Table - Quad Table}

Production quality software often times approaches large data use in terms of iterative calls.  Every recursive call places a number things on a stack, including activation records and their activation record stack.   As a result, stack management becomes an issue if recursive calls dominate the software package.   The example grammar has calls to many components and the semantic action stack and other stacks grow quickly.  


There is a link between the symbol table and quad table.  Constants and identifiers are pointers into the symbol table.  


Question: How do we handle arrays?  

(X(1)) ((a(1)) (a(2))) := 

Suggestions:  
\begin{itemize}
\item Offsets.  Note that offsets require a good deal of knowledge about the machine, and quads are supposed to be machine independent.  
\item A header to linked lists of arguments that make up operand 1 and 2.  
\item Add fields to the quad table.  The obvious problem is that there is a limit to the number of subscripts that user can be allowed to use.  There are languages that limit the number of subscripts one can have to an array, and the reason may be how the quad table addresses them.  

\end{itemize}

Offsets.  Note that offsets require a good deal of knowledge about the machine, and quads are supposed to be machine independent.  
A header to linked lists of arguments that make up operand 1 and 2.  
Add fields to the quad table.  The obvious problem is that there is a limit to the number of subscripts that user can be allowed to use.  There are languages that limit the number of subscripts one can have to an array, and the reason may be how the quad table addresses them.  


Memory segment/ block

Object Code

integer array

data

Activation records $\to$ Heaps
Compiler Run Time

Code generation takes the Symbol Table and Quad Table and uses them to generate object and data sections.   Quad tables support data flow optimization.  

Error catch can occur in one of two places 
Compiler Run Time 
OS Run Time 

Garbage collection serves two purposes:
\begin{itemize}
\item It covers for sloppy code
\item It handles checkerboard type memory management within the process
\item Prevents memory writes from overwriting object code or other critial sections.  
\end{itemize}

\textbf{Example}
The old scheme of IBM's database system included a system called IMS DB/DC.   It was a hierarchical database, and did not survive in use much beyond 1985.  It used COBOL queries which were translated into OS 370 operation code, and that code managed the database.  One error noted occurred when a program was run that produced a boundary condition error.  In the process the program overwrote sections of the object code itself.  With no boundary protection for data, heap and object code sections, the program can otherwise destroy itself.  The typical error for this at the time IBM was using this scheme was unrecognizable operation code, which was an assembler code error.  

\section {\Large Semantic Actions Positions}

\[ P\to \alpha_0 D_1 \alpha_{12} S_L \alpha_{13}\]

\[ D_1 \to I_L \alpha_{31} D | \epsilon \]

\[ D \to \alpha _1 \alpha_{14} cons D_2 \alpha_{15} \alpha_{16} D_1 | \alpha_2 \alpha_{16} D_1 \]

\[ D_2 \to \alpha_{17} cons D_2 |  \epsilon \]

\[ I_L \to \alpha _{-1} I_L \]

\[ I_{L_1} \to \alpha _{17} I_L  | \epsilon \]

\[ I_D	 \to  	i_d I'_D \]

\[  I'_D \to [ S_u ]  | \epsilon \]

\[ T\to I_D | \alpha_{11} | cons \]

\[ S_u \to	i_d S'_u | cons S''_u \]
\[ S'_u \to i_d \alpha_{17} S_u  \]
\[ S''_u \to \alpha_{-2} \alpha_{17} S_u \]

\[ S \to \alpha_{12} S_L \alpha_{13} S' |  \alpha_5 | \alpha_6 |  \alpha_{18} I_L \alpha_{19} S'' \]

\[ S' \to \alpha_7 C | \alpha_8 C | i_d \alpha_{9} \alpha_{14} E \alpha_{10} E \alpha_{15} \]

\[ S'' \to \alpha_{18} E_L \alpha_{19} \alpha_{20} | \alpha_{3} | \alpha_{4} \]

\[ E \to \alpha_{18} E_L \alpha_{19}  \alpha_{18} E_L \alpha_{19}  E' | T \]

\[ E' \to  \alpha_{27} | \alpha_{28} | \alpha_{29} | \alpha_{30} |  \alpha_{35} \]

\[ E_L \to E E'_L | \epsilon \]

\[ E'_L \to \alpha_{17} E_L \]

\[ C \to (E_L )(E_L) C'' | \epsilon  \]

\[C' \to \alpha_{16} C C'''\]

\[ C'' \to \alpha _{21} C' | \alpha _{22} C' | \alpha _{23} C' | \alpha _{24} C' | \alpha _{25} C' | \alpha _{26}  C' \]

\[ C''' \to \alpha_{32} C' | \alpha_{33} C' | \alpha_{34} C' \]

\[ S_L \to S S'_L\]
\[S'_L \to \alpha_{16} | \epsilon\] 

\textbf {Primary Semantic Actions}
\[ P\to program\  D_1 \{ S_L \}\]

\[ S \to \{ S_L \} S' |  rdln | wrln |  ( I_L ) S'' \]

\[ S' \to when \ C | until \ C | i_d \ from \ [ E \alpha_{10} E ] \]

\[ S'' \to ( E_L ) := | read | write \]

\[ E \to ( E_L )  ( E_L )  E' | T \]

\[ E' \to  + \hspace{0.5 cm}| - \hspace{0.5 cm} | \ast \hspace{0.5 cm}| / \hspace{0.5 cm} |  mod \]

\[ E_L \to E E'_L | \epsilon \]

\[ E'_L \to , E_L | \epsilon \]

\[ C \to (E_L )(E_L) C''   \]

\[C' \to  ; C C''' | not\  C'  | \epsilon \]  

\[ C'' \to < C' | >  C' | = C' | <= C' | >= C' | <>  C' \]

\[ C''' \to and  C' | or C'  \]

\[ S_L \to S S'_L\]

\[S'_L \to ; | \epsilon\] 

\newpage
\subsection{\Large Semantic Actions on S'}

\begin {algorithm}
\caption{ Semantic action $G_0$ }
\label{alg:G0}
\begin{algorithmic}
\STATE \texttt { A := POP (SAS) }  Work Section Quad
\STATE \texttt { B := POP (SAS) }  Next Quad from $\{S_L\} S'$
\STATE \texttt { QT[B,4]  :=  NQ }  
\STATE \texttt { PUSH (A) }

\end{algorithmic}
\end{algorithm}

\begin {algorithm}
\caption{ Semantic action $G_1$ (when C' decision) }
\label{alg:G1}
\begin{algorithmic}
\STATE \texttt { c := POP (SAS) }  result of C
\STATE \texttt { b := POP (SAS) }  work quad 
\STATE \texttt { d := POP (SAS) }  exit quad
\STATE \texttt { genquad (jeq, C, F, b) }     jump to work
\STATE \texttt { quads [d] results := NQ }  adjust exit quad jump
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{ Semantic action $G_2$ (until jump condition)}
\label{alg:G2}
\begin{algorithmic}
\STATE \texttt {C := pop (SAS) } condition result
\STATE \texttt {a := pop (SAS) } work quad
\STATE \texttt {genquad (jeq, C, F, a) } jump condition for until
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{ Semantic action $G_3$ (until test condition)}
\label{alg:G2}
\begin{algorithmic}
\STATE \texttt {a := pop (SAS) } work quad
\STATE \texttt {  b := pop (SAS) } start  result
\STATE \texttt {quads [b] results := NQ }
\STATE \texttt {push (a) }  preserve work quad
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{ Semantic action $G_4$}
\label{alg:G4}
\begin{algorithmic}
\STATE push (id)
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{ Semantic action $G_5$}
\label{alg:g5}
\begin{algorithmic}
\STATE \texttt {c := pop(SAS)} (result of expression RHS)
\STATE \texttt{d := pop(SAS)} (id LHS)
\STATE \texttt{b := pop(SAS)} (work quad )
\STATE \texttt{a := pop(SAS)} (start quad )
\STATE \texttt {quads [a] result := NQ }  (adjust start jump to initialization section)
\STATE \texttt {e := NQ }   preserve jump to test location
\STATE \texttt {genquad (jmp, \_ , \_ , \_) }
\STATE \texttt {genquad (:=, c, \_ , d ) }   initialize id with the value of the expression (presumption of single element expression result).  
\STATE \texttt {push (e, SAS)} preserve test jump
\STATE \texttt{push (d)}  preserve id
\STATE \texttt{push(b)}  preserve work jum
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{ Semantic action $G_6$}
\label{alg:g6}
\begin{algorithmic}
\STATE \texttt{f  := gentemp}  Expression result
\STATE \texttt{b := pop (SAS)}   work jump point 
\STATE \texttt {d := pop (SAS) }  id 
\STATE \texttt {e := pop (SAS) }  test jump point
\STATE \texttt { quads[e] result := NQ }  adjust test jump point to this test
\STATE \texttt { g := gentemp }  temporary variable 
\STATE \texttt {genquad ( <= , d, f, g)  }
\STATE \texttt {genquad ( + , d , 1, d )}
\STATE \texttt {genquad ( jeq, c, true , b )}
\end{algorithmic}
\end{algorithm}
 
 \begin{algorithm}
\caption{ Semantic action $G_7$}
\label{alg:g7}
\begin{algorithmic}
 \STATE \texttt{a := NQ}
 \STATE \texttt{genquad(jmp, \_ , \_, \_ )}
 \STATE \texttt{b := NQ}
 \STATE \texttt{push (a, SAS)}
 \STATE \texttt{push (b, SAS)}
\end{algorithmic}
\end{algorithm}


\newpage
\subsection {Condition and Expression Semantic Actions}

\begin {algorithm}
\caption{ Semantic action $W_1$}
\label{alg:w1}
\begin{algorithmic}
\STATE \texttt {push (\#)}
\end{algorithmic}
\end{algorithm}

\begin {algorithm}
\caption{ Semantic action $W_2$}
\label{alg:W2}
\begin{algorithmic}
\STATE \texttt {a := pop (SAS) }
\STATE \texttt {while $a \neq \# $ do }
\STATE \hspace {0.5 cm}  \texttt {push (a, $S_1$ ) }
\STATE \hspace {0.5 cm} \texttt { a := pop (SAS) }
\end{algorithmic}
\end{algorithm}

\begin {algorithm}
\caption{ Semantic action $X_o$}
\label{alg:wo}
\begin{algorithmic}
\REQUIRE Op Code to be generated: $O$
\STATE \texttt {a := pop (SAS) }
\STATE \texttt {while $a \neq \# $ do }
\STATE \hspace {0.5 cm}  \texttt {push (a, $S_1$ ) }
\STATE \hspace {0.5 cm} \texttt {a := pop (SAS) }
\STATE \texttt { push (\#)  }
\STATE \texttt { a := pop ($S_1$) } 
\STATE \texttt { b := pop ($S_2$) } 
\STATE \texttt {while $a \neq \emptyset $ do }
\STATE \hspace {0.5 cm} \texttt {c := gentemp}
\STATE \hspace {0.5 cm} \texttt {genquad (O, a, b, c) }
\STATE  \hspace {0.5 cm} \texttt {push (c, SAS) } 
\STATE  \hspace {0.5 cm} \texttt {a := pop ($S_1$) } 
\STATE  \hspace {0.5 cm} \texttt {b := pop ($S_2$) } 

\end{algorithmic}
\end{algorithm}

\begin {algorithm}
\caption{ Semantic action $X_{not}$}
\label{alg:xnot}
\begin{algorithmic}
\STATE \texttt { a := pop ($S_1$) } 
\STATE \texttt {while $a \neq \emptyset $ do }
\STATE \hspace {0.5 cm} \texttt {c := gentemp}
\STATE \hspace {0.5 cm} \texttt {genquad (O, a, b, c) }
\STATE  \hspace {0.5 cm} \texttt {push (c, SAS) } 
\STATE  \hspace {0.5 cm} \texttt {a := pop ($S_1$) } 

\end{algorithmic}
\end{algorithm}

\newpage
\subsection {Declarations}

\begin{algorithm}
\caption{ Semantic Action for $I_0$}
\label{alg:I0}
\begin{algorithmic}
\STATE push (\#, SAS)

\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{ Semantic Action for $I_1$}
\label{alg:I1}
\begin{algorithmic}
\STATE a := int
\STATE b := pop (SAS)
\STATE while ( $b \neq \#$)
\STATE \hspace {0.5 cm} change symbol table entry b's type to the value of a 
\STATE \hspace {0.5 cm} b := pop (SAS)

\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{ Semantic Action for $I_2$}
\label{alg:I2}
\begin{algorithmic}
\STATE a := id 
\STATE push (a, SAS)

\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{ Semantic Action for $I_3$}
\label{alg: I3}
\begin{algorithmic}
\STATE push (\# , SAS)
\STATE push ( cons, SAS)

\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{ Semantic Action for $I_4$}
\label{alg: I4}
\begin{algorithmic}
\REQUIRE A temporary dimension structure temp-dim
\STATE a := pop(SAS)
\STATE while ( $a \neq \#$ )
\STATE \hspace {0.5 cm} tempdim adddim: a
\STATE \hspace{0.5 cm} pop a
\STATE b := pop (SAS)
\STATE while ( $b \neq \#$)
\STATE \hspace {0.5 cm} ST setdimension: tempdim in\_symbol:b
\STATE \hspace {0.5 cm} b := pop (SAS)
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{ Semantic Action for $I_5$}
\label{alg: I5}
\begin{algorithmic}
\STATE push ( cons, SAS)

\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{ Semantic Action for $I_6$}
\label{alg: I6}
\begin{algorithmic}
\STATE push ( cons, SAS)

\end{algorithmic}
\end{algorithm}


\subsection {Constants and Lists}
\[ T\to I_D | \alpha_{11} | cons \]

\[ S_u \to	i_d S'_u | cons S''_u \]

\[ S'_u \to \ ; \  i_d \ S_u  \]

\[ S''_u \to \ ; \  \alpha_{-2} S_u \]

\[ S'' \to ( E_L ) \ := \  | \ read \ | \ write \]

\begin{algorithm}
\caption{ Semantic Action for $I_7$}
\label{alg: I7}
\begin{algorithmic}
\STATE A := pop (SAS)
\STATE while A $\neq$ \# do 
\STATE \hspace{0.5 cm} push (A,S1)
\STATE \hspace{0.5 cm} A := pop (SAS)
\STATE A := pop(SAS)
\STATE while A $\neq$ \# do
\STATE \hspace{0.5 cm} push (A, S2)
\STATE \hspace{0.5 cm} A := pop (SAS)
\STATE A := pop (S1)
\STATE B := pop(S2)
\STATE while A $\neq$ \# empty do
\STATE \hspace{0.5 cm} genquad ( = A, \_ , B)
\STATE \hspace{0.5 cm} A := pop(S1)
\STATE \hspace{0.5 cm} B := pop(S2)
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{ Semantic Action for $I_8$}
\label{alg: I10}
\begin{algorithmic}
\STATE A := pop (SAS)
\STATE while A $\neq$ \# do 
\STATE \hspace{0.5 cm} push (A,S1)
\STATE \hspace{0.5 cm} A := pop (SAS)
\STATE A := pop(SAS)
\STATE while A $\neq$ \# do
\STATE \hspace{0.5 cm} push (A, S2)
\STATE \hspace{0.5 cm} A := pop (SAS)
\STATE A := pop (S1)
\STATE B := pop(S2)
\STATE while A $\neq$ \# empty do
\STATE \hspace{0.5 cm} genquad ( = A, \_ , B)
\STATE \hspace{0.5 cm} A := pop(S1)
\STATE \hspace{0.5 cm} B := pop(S2)
\end{algorithmic}
\end{algorithm}


 \end{document} 